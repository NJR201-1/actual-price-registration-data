# -*- coding: utf-8 -*-
"""é å”®å±‹.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ACrG6bvUiTWKX_KKALRKDLPiOXOkU5hI
"""

# åŒ¯å…¥å…¨å°çš„è¡Œæ”¿å€
import json

PATH_CITIES_FILE = "/content/drive/MyDrive/Colab Notebooks/Tibame_20250412_Project/cities.json"
with open(PATH_CITIES_FILE, 'r', encoding='utf-8') as f:
    cities = json.load(f)

# install module

# !pip install selenium
# !pip install undetected_chromedriver

from selenium import webdriver
import undetected_chromedriver as uc

# Provide the explicit path to the Chrome executable
driver = uc.Chrome()

from datetime import datetime
import time
import json
import os
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
import undetected_chromedriver as uc
import requests
import urllib.parse

SECONDS_DELAY = 5 # ç­‰å¾…ç¶²é è¼‰å…¥çš„ç§’æ•¸
REQUEST_TIMEOUT = 60 # requests çš„é€¾æ™‚æ™‚é–“
DIRECTORY = 'data'
CITIES_URL = "https://gist.githubusercontent.com/abc873693/2804e64324eaaf26515281710e1792df/raw/a1e1fc17d04b47c564bbd9dba0d59a6a325ec7c1/taiwan_districts.json"

URL_INDEX = 'https://lvr.land.moi.gov.tw/jsp/list.jsp'

year = datetime.now().year - 1911  # æ°‘åœ‹å¹´
month = datetime.now().month

# è®€å–åŸå¸‚èˆ‡è¡Œæ”¿å€è³‡æ–™
# try:
#     response = requests.get(CITIES_URL, timeout=30)
#     response.raise_for_status()
#     cities = json.loads(response.text)
#     print(f"æˆåŠŸè¼‰å…¥ {len(cities)} å€‹åŸå¸‚è³‡æ–™")
# except requests.RequestException as e:
#     print(f"ç„¡æ³•è¼‰å…¥åŸå¸‚è³‡æ–™: {e}")
#     exit(1)
# except json.JSONDecodeError as e:
#     print(f"JSONè§£æéŒ¯èª¤: {e}")
#     exit(1)

# å»ºç«‹æŸ¥è©¢åˆ—è¡¨
queries = []
for city in cities:
    if 'districts' in city:
        for district in city['districts']:
            query = {
                'city': {'id': city.get('id'), 'name': city.get('name')},
                'town': {'id': district.get('id'), 'name': district.get('name')},
                'url': None,
                'payload': None
            }
            queries.append(query)

print(f"ç¸½å…±å»ºç«‹ {len(queries)} å€‹æŸ¥è©¢")

# æŸ¥è©¢åƒæ•¸
params = {
    "ptype": "1,2,3,4,5",
    "starty": "101",
    "startm": "1",
    "endy": str(year),
    "endm": str(month),
    "qryType": "biz",
    "city": "A",
    "town": "A15",
    "p_build": "",
    "ftype": "",
    "price_s": "",
    "price_e": "",
    "unit_price_s": "",
    "unit_price_e": "",
    "area_s": "",
    "area_e": "",
    "build_s": "",
    "build_e": "",
    "buildyear_s": "",
    "buildyear_e": "",
    "doorno": "",
    "pattern": "",
    "community": "",
    "floor": "",
    "rent_type": "",
    "rent_order": "",
    "urban": "",
    "urbantext": "",
    "nurban": "",
    "aa12": "",
    "p_purpose": "",
    "p_unusual_yn": "",
    "p_unusualcode": "",
    "QB41": "",
    "tmoney_unit": "1",
    "pmoney_unit": "1",
    "unit": "2",
    "token": ""
}

params_collection = [dict(params, city=query.get('city').get('id'), town=query.get('town').get('id')) for query in queries]

# æ‰‹å‹•æŒ‡å®š Chrome åŸ·è¡Œæª”è·¯å¾‘
CHROME_PATH = r"C:\Program Files\Google\Chrome\Application\chrome.exe"

# å•Ÿç”¨ Performance Log
caps = DesiredCapabilities.CHROME
caps['goog:loggingPrefs'] = {'performance': 'ALL'}

options = uc.ChromeOptions()
options.add_argument('--disable-blink-features=AutomationControlled')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
options.add_argument('--disable-gpu')
options.add_argument('--remote-debugging-port=9222')
options.add_experimental_option("excludeSwitches", ["enable-automation"])
options.add_experimental_option('useAutomationExtension', False)

# è¨­å®š Chrome åŸ·è¡Œæª”è·¯å¾‘
if os.path.exists(CHROME_PATH):
    options.binary_location = CHROME_PATH
    print(f"ä½¿ç”¨æŒ‡å®šçš„ Chrome åŸ·è¡Œæª”: {CHROME_PATH}")
else:
    print(f"è­¦å‘Š: æ‰¾ä¸åˆ°æŒ‡å®šçš„ Chrome åŸ·è¡Œæª”: {CHROME_PATH}")
    print("è«‹ç¢ºèª Chrome å®‰è£è·¯å¾‘æ˜¯å¦æ­£ç¢º")

try:
    driver = uc.Chrome(options=options, desired_capabilities=caps, browser_executable_path="C:\Program Files\Google\Chrome\Application\chrome.exe")
    print("Chrome ç€è¦½å™¨å•Ÿå‹•æˆåŠŸ")
except Exception as e:
    print(f"Chrome å•Ÿå‹•å¤±æ•—: {e}")
    print("å˜—è©¦ä¸ä½¿ç”¨éƒ¨åˆ†åƒæ•¸é‡è©¦...")
    try:
        # ç°¡åŒ–é¸é …é‡è©¦
        options = uc.ChromeOptions()
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        if os.path.exists(CHROME_PATH):
            options.binary_location = CHROME_PATH
        driver = uc.Chrome(options=options, desired_capabilities=caps)
        print("Chrome ç€è¦½å™¨å•Ÿå‹•æˆåŠŸï¼ˆç°¡åŒ–æ¨¡å¼ï¼‰")
    except Exception as e2:
        print(f"Chrome å•Ÿå‹•ä»ç„¶å¤±æ•—: {e2}")
        print("è«‹æª¢æŸ¥ä»¥ä¸‹é …ç›®:")
        print("1. Chrome æ˜¯å¦å·²æ­£ç¢ºå®‰è£")
        print("2. Chrome è·¯å¾‘æ˜¯å¦æ­£ç¢º")
        print("3. æ˜¯å¦æœ‰è¶³å¤ çš„ç³»çµ±æ¬Šé™")
        exit(1)

# è¨­ç½® user agent
driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

# å•Ÿç”¨ Network domain
driver.execute_cdp_cmd("Network.enable", {})

# é–‹å•Ÿå¯¦åƒ¹ç™»éŒ„ç¶²ç«™
print("æ­£åœ¨è¼‰å…¥å¯¦åƒ¹ç™»éŒ„ç¶²ç«™...")
driver.get(URL_INDEX)
time.sleep(SECONDS_DELAY)

# åŸ·è¡Œå‰ç«¯è…³æœ¬ï¼Œæ‰¹æ¬¡ç”¢ç”ŸæŸ¥è©¢ç¶²å€
print("æ­£åœ¨åŸ·è¡Œå‰ç«¯è…³æœ¬ç”ŸæˆæŸ¥è©¢...")
script = f"""
    var params_collection = {json.dumps(params_collection)};
    console.log('é–‹å§‹åŸ·è¡ŒæŸ¥è©¢ï¼Œå…±', params_collection.length, 'ç­†');

    // é€ä¸€è§¸ç™¼æŸ¥è©¢
    for (let i = 0; i < params_collection.length; i++) {{
        try {{
            console.log('åŸ·è¡ŒæŸ¥è©¢', i + 1, '/', params_collection.length);
            window.common.loadQueryPrice2(params_collection[i]);
        }} catch (e) {{
            console.error('æŸ¥è©¢å¤±æ•—:', e);
        }}
    }}
    console.log('æ‰€æœ‰æŸ¥è©¢å·²è§¸ç™¼');
"""

driver.execute_script(script)

# ç­‰å¾…æ‰€æœ‰è«‹æ±‚å®Œæˆ
print("ç­‰å¾…ç¶²è·¯è«‹æ±‚å®Œæˆ...")
time.sleep(10)  # å¢åŠ ç­‰å¾…æ™‚é–“ç¢ºä¿æ‰€æœ‰è«‹æ±‚éƒ½è¢«è¨˜éŒ„

# å¾ Network Log ä¸­æ“·å–æŸ¥è©¢ç¶²å€å’Œ payload
print("æ­£åœ¨åˆ†æç¶²è·¯æ—¥èªŒ...")
i = 0
log_entries = driver.get_log("performance")

for entry in log_entries:
    try:
        log = entry['message']
        logJson = json.loads(log)
        message = logJson.get('message', {})
        method = message.get('method', '')

        if method == 'Network.requestWillBeSent':
            request_data = message.get('params', {}).get('request', {})
            url = request_data.get('url', '')

            # æª¢æŸ¥æ˜¯å¦ç‚ºç›®æ¨™ API è«‹æ±‚
            if '/SERVICE/QueryPrice' in url:
                print(f"æ‰¾åˆ° API è«‹æ±‚ {i + 1}: {url}")

                if i < len(queries):
                    queries[i]['url'] = url

                    # æª¢æŸ¥æ˜¯å¦æœ‰ POST è³‡æ–™
                    post_data = request_data.get('postData', '')
                    if post_data:
                        queries[i]['payload'] = post_data
                        print(f"  - åŒ…å« POST è³‡æ–™: {post_data[:100]}...")

                    # æª¢æŸ¥ URL åƒæ•¸
                    parsed_url = urllib.parse.urlparse(url)
                    query_params = urllib.parse.parse_qs(parsed_url.query)
                    if 'q' in query_params:
                        print(f"  - å‹•æ…‹åƒæ•¸ q: {query_params['q'][0][:50]}...")

                    i += 1

    except (json.JSONDecodeError, KeyError) as e:
        continue

driver.quit()
print(f"æˆåŠŸç²å– {i} å€‹æŸ¥è©¢ç¶²å€")

# é€é requests æ¨¡çµ„ç™¼é€è«‹æ±‚ä¸¦å„²å­˜è³‡æ–™
success_count = 0
for idx, query in enumerate(queries):
    if not query['url']:
        print(f"è·³éæ²’æœ‰URLçš„æŸ¥è©¢: {query['city']['name']} {query['town']['name']}")
        continue

    CITY_NAME = query['city'].get('name')
    DISTRICT_NAME = query['town'].get('name')

    # å»ºç«‹ç›®éŒ„
    dir_path = os.path.join(DIRECTORY, CITY_NAME)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

    file_path = os.path.join(dir_path, f'{DISTRICT_NAME}.json')

    # æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å·²å­˜åœ¨
    if os.path.exists(file_path):
        print(f"æª”æ¡ˆå·²å­˜åœ¨ï¼Œè·³é: {CITY_NAME} {DISTRICT_NAME}")
        continue

    print(f"æ­£åœ¨æŸ¥è©¢ [{idx+1}/{len(queries)}]: {CITY_NAME} {DISTRICT_NAME}")

    try:
        # è¨­ç½®è«‹æ±‚æ¨™é ­
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Referer': 'https://lvr.land.moi.gov.tw/jsp/list.jsp',
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Accept-Language': 'zh-TW,zh;q=0.9,en;q=0.8',
            'X-Requested-With': 'XMLHttpRequest'
        }

        # ç™¼é€è«‹æ±‚
        if query['payload']:
            # å¦‚æœæœ‰ POST è³‡æ–™ï¼Œä½¿ç”¨ POST è«‹æ±‚
            response = requests.post(
                query['url'],
                data=query['payload'],
                headers=headers,
                timeout=REQUEST_TIMEOUT
            )
        else:
            # å¦å‰‡ä½¿ç”¨ GET è«‹æ±‚
            response = requests.get(
                query['url'],
                headers=headers,
                timeout=REQUEST_TIMEOUT
            )

        response.raise_for_status()

        # å„²å­˜è³‡æ–™
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(response.text)

        print(f"  âœ“ æˆåŠŸå„²å­˜: {CITY_NAME} {DISTRICT_NAME}")
        success_count += 1

    except Exception as e:
        print(f"  âœ— éŒ¯èª¤: {CITY_NAME} {DISTRICT_NAME} - {str(e)}")
        continue

    # å»¶é²é¿å…è¢«å°é–
    time.sleep(SECONDS_DELAY)

print(f"\nçˆ¬å–å®Œæˆï¼æˆåŠŸç²å– {success_count} å€‹è¡Œæ”¿å€çš„è³‡æ–™")

import asyncio
from playwright.async_api import async_playwright
import json
import os
import time
from datetime import datetime
import nest_asyncio
import aiohttp

nest_asyncio.apply()  # é¿å… Jupyter ç’°å¢ƒå ± asyncio.run éŒ¯

SECONDS_DELAY = 5
REQUEST_TIMEOUT = 60
DIRECTORY = 'data'
CITIES_URL = "https://gist.githubusercontent.com/abc873693/2804e64324eaaf26515281710e1792df/raw/a1e1fc17d04b47c564bbd9dba0d59a6a325ec7c1/taiwan_districts.json"
URL_INDEX = 'https://lvr.land.moi.gov.tw/jsp/list.jsp'

year = datetime.now().year - 1911
month = datetime.now().month

async def main():
    # è®€å–åŸå¸‚èˆ‡è¡Œæ”¿å€è³‡æ–™
    async with aiohttp.ClientSession() as session:
        async with session.get(CITIES_URL) as resp:
            text = await resp.text()
            cities = json.loads(text)
    print(f"âœ… æˆåŠŸè¼‰å…¥ {len(cities)} å€‹åŸå¸‚è³‡æ–™")

    queries = []
    for city in cities:
        if 'districts' in city:
            for district in city['districts']:
                queries.append({
                    'city': {'id': city.get('id'), 'name': city.get('name')},
                    'town': {'id': district.get('id'), 'name': district.get('name')},
                })
    print(f"âœ… ç¸½å…±å»ºç«‹ {len(queries)} å€‹æŸ¥è©¢")

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()

        results = {}

        # æ””æˆª JSON å›æ‡‰
        async def handle_response(response):
            if "/SERVICE/QueryPrice" in response.url:
                try:
                    data = await response.json()
                    results[response.url] = data
                    print(f"ğŸ“¥ æˆåŠŸå–å¾—è³‡æ–™: {response.url}")
                except Exception as e:
                    print(f"âŒ è§£æ JSON å¤±æ•—: {response.url} - {str(e)}")

        page.on("response", handle_response)

        await page.goto(URL_INDEX)
        await asyncio.sleep(SECONDS_DELAY)

        # æŸ¥è©¢åƒæ•¸
        params = {
            # å‹æ…‹
            #  1. æˆ¿åœ°
            #  2. æˆ¿åœ°ï¼ˆè»Šï¼‰
            #  3. åœŸåœ°
            #  4. å»ºç‰©
            #  5. è»Šä½
            "ptype": "1,2,3,4,5",

            # æŸ¥è©¢èµ·å§‹å¹´
            "starty": "101",

            # æŸ¥è©¢èµ·å§‹æœˆ
            "startm": "1",

            # æŸ¥è©¢çµæŸå¹´
            "endy": str(year),

            # æŸ¥è©¢çµæŸæœˆ
            "endm": str(month),

            # æŸ¥è©¢é¡å‹
            # biz: ã€Œè²·è³£æŸ¥è©¢ã€
            # rent: ã€Œç§Ÿè³ƒæŸ¥è©¢ã€
            # sale: ã€Œé å”®å±‹æŸ¥è©¢ã€
            "qryType": "biz",

            # åŸå¸‚
            "city": "A",

            # è¡Œæ”¿å€
            "town": "A15",

            # ç¤¾å€åç¨±
            "p_build": "",

            # ã€Œé¡å‹ã€ï¼å…¬å¯“ã€å» æˆ¿...ï¼Œåƒ…é™ã€Œç§Ÿè³ƒæŸ¥è©¢ã€
            "ftype": "",

            # ç§Ÿé‡‘ç¸½é¡ï¼æœ€ä½ï¼Œåƒ…é™ã€Œç§Ÿè³ƒæŸ¥è©¢ã€
            "price_s": "",

            # ç§Ÿé‡‘ç¸½é¡ï¼æœ€é«˜
            "price_e": "",

            # æœ€ä½å–®åƒ¹
            "unit_price_s": "",

            # æœ€é«˜å–®åƒ¹
            "unit_price_e": "",

            # æœ€ä½é¢ç©
            "area_s": "",

            # æœ€é«˜é¢ç©
            "area_e": "",

            "build_s": "",
            "build_e": "",

            # æœ€ä½å±‹é½¡
            "buildyear_s": "",

            # æœ€é«˜å±‹é½¡
            "buildyear_e": "",

            "doorno": "",
            "pattern": "",
            "community": "",
            "floor": "",
            "rent_type": "",
            "rent_order": "",
            "urban": "",
            "urbantext": "",
            "nurban": "",
            "aa12": "",
            "p_purpose": "",
            "p_unusual_yn": "",
            "p_unusualcode": "",
            "QB41": "",
            "tmoney_unit": "1",

            # å–®åƒ¹å–®ä½
            # 1: è¬å…ƒ
            # 2: å…ƒ
            "pmoney_unit": "1",

            # é¢ç©å–®ä½
            # 1: å¹³æ–¹å…¬å°º
            # 2: åª,
            "unit": "2",

            # token
            "token": ""
        }

        params_collection = [dict(params, city=query.get('city').get('id'), town=query.get('town').get('id')) for query in queries]

        # ä¾åºæŸ¥è©¢
        for idx, q in enumerate(queries):
            query_params = dict(params)
            query_params["city"] = q['city']['id']
            query_params["town"] = q['town']['id']
            print(f"ğŸ” æŸ¥è©¢ {idx+1}/{len(queries)}: {q['city']['name']} {q['town']['name']}")

            await page.evaluate("window.common.loadQueryPrice2", query_params)
            await asyncio.sleep(1.5)  # ç¨å¾®ç­‰ä¸€ä¸‹é¿å…ä¼ºæœå™¨éè¼‰

        print("âŒ› ç­‰å¾…æ‰€æœ‰è³‡æ–™å›æ‡‰...")
        await asyncio.sleep(10)

        # å°‡è³‡æ–™å­˜æˆæª”æ¡ˆ
        for url, data in results.items():
            matched = None
            for q in queries:
                if f"city={q['city']['id']}" in url and f"town={q['town']['id']}" in url:
                    matched = q
                    break
            if matched:
                city_name = matched['city']['name']
                town_name = matched['town']['name']
                dir_path = os.path.join(DIRECTORY, city_name)
                os.makedirs(dir_path, exist_ok=True)
                file_path = os.path.join(dir_path, f"{town_name}.json")
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                print(f"ğŸ’¾ å·²å„²å­˜: {city_name} {town_name}")

        await browser.close()
        print("âœ… æ‰€æœ‰æµç¨‹å®Œæˆ")
asyncio.run(main())

