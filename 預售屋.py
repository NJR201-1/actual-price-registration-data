# -*- coding: utf-8 -*-
"""預售屋.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ACrG6bvUiTWKX_KKALRKDLPiOXOkU5hI
"""

# 匯入全台的行政區
import json

PATH_CITIES_FILE = "/content/drive/MyDrive/Colab Notebooks/Tibame_20250412_Project/cities.json"
with open(PATH_CITIES_FILE, 'r', encoding='utf-8') as f:
    cities = json.load(f)

# install module

# !pip install selenium
# !pip install undetected_chromedriver

from selenium import webdriver
import undetected_chromedriver as uc

# Provide the explicit path to the Chrome executable
driver = uc.Chrome()

from datetime import datetime
import time
import json
import os
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
import undetected_chromedriver as uc
import requests
import urllib.parse

SECONDS_DELAY = 5 # 等待網頁載入的秒數
REQUEST_TIMEOUT = 60 # requests 的逾時時間
DIRECTORY = 'data'
CITIES_URL = "https://gist.githubusercontent.com/abc873693/2804e64324eaaf26515281710e1792df/raw/a1e1fc17d04b47c564bbd9dba0d59a6a325ec7c1/taiwan_districts.json"

URL_INDEX = 'https://lvr.land.moi.gov.tw/jsp/list.jsp'

year = datetime.now().year - 1911  # 民國年
month = datetime.now().month

# 讀取城市與行政區資料
# try:
#     response = requests.get(CITIES_URL, timeout=30)
#     response.raise_for_status()
#     cities = json.loads(response.text)
#     print(f"成功載入 {len(cities)} 個城市資料")
# except requests.RequestException as e:
#     print(f"無法載入城市資料: {e}")
#     exit(1)
# except json.JSONDecodeError as e:
#     print(f"JSON解析錯誤: {e}")
#     exit(1)

# 建立查詢列表
queries = []
for city in cities:
    if 'districts' in city:
        for district in city['districts']:
            query = {
                'city': {'id': city.get('id'), 'name': city.get('name')},
                'town': {'id': district.get('id'), 'name': district.get('name')},
                'url': None,
                'payload': None
            }
            queries.append(query)

print(f"總共建立 {len(queries)} 個查詢")

# 查詢參數
params = {
    "ptype": "1,2,3,4,5",
    "starty": "101",
    "startm": "1",
    "endy": str(year),
    "endm": str(month),
    "qryType": "biz",
    "city": "A",
    "town": "A15",
    "p_build": "",
    "ftype": "",
    "price_s": "",
    "price_e": "",
    "unit_price_s": "",
    "unit_price_e": "",
    "area_s": "",
    "area_e": "",
    "build_s": "",
    "build_e": "",
    "buildyear_s": "",
    "buildyear_e": "",
    "doorno": "",
    "pattern": "",
    "community": "",
    "floor": "",
    "rent_type": "",
    "rent_order": "",
    "urban": "",
    "urbantext": "",
    "nurban": "",
    "aa12": "",
    "p_purpose": "",
    "p_unusual_yn": "",
    "p_unusualcode": "",
    "QB41": "",
    "tmoney_unit": "1",
    "pmoney_unit": "1",
    "unit": "2",
    "token": ""
}

params_collection = [dict(params, city=query.get('city').get('id'), town=query.get('town').get('id')) for query in queries]

# 手動指定 Chrome 執行檔路徑
CHROME_PATH = r"C:\Program Files\Google\Chrome\Application\chrome.exe"

# 啟用 Performance Log
caps = DesiredCapabilities.CHROME
caps['goog:loggingPrefs'] = {'performance': 'ALL'}

options = uc.ChromeOptions()
options.add_argument('--disable-blink-features=AutomationControlled')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
options.add_argument('--disable-gpu')
options.add_argument('--remote-debugging-port=9222')
options.add_experimental_option("excludeSwitches", ["enable-automation"])
options.add_experimental_option('useAutomationExtension', False)

# 設定 Chrome 執行檔路徑
if os.path.exists(CHROME_PATH):
    options.binary_location = CHROME_PATH
    print(f"使用指定的 Chrome 執行檔: {CHROME_PATH}")
else:
    print(f"警告: 找不到指定的 Chrome 執行檔: {CHROME_PATH}")
    print("請確認 Chrome 安裝路徑是否正確")

try:
    driver = uc.Chrome(options=options, desired_capabilities=caps, browser_executable_path="C:\Program Files\Google\Chrome\Application\chrome.exe")
    print("Chrome 瀏覽器啟動成功")
except Exception as e:
    print(f"Chrome 啟動失敗: {e}")
    print("嘗試不使用部分參數重試...")
    try:
        # 簡化選項重試
        options = uc.ChromeOptions()
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        if os.path.exists(CHROME_PATH):
            options.binary_location = CHROME_PATH
        driver = uc.Chrome(options=options, desired_capabilities=caps)
        print("Chrome 瀏覽器啟動成功（簡化模式）")
    except Exception as e2:
        print(f"Chrome 啟動仍然失敗: {e2}")
        print("請檢查以下項目:")
        print("1. Chrome 是否已正確安裝")
        print("2. Chrome 路徑是否正確")
        print("3. 是否有足夠的系統權限")
        exit(1)

# 設置 user agent
driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

# 啟用 Network domain
driver.execute_cdp_cmd("Network.enable", {})

# 開啟實價登錄網站
print("正在載入實價登錄網站...")
driver.get(URL_INDEX)
time.sleep(SECONDS_DELAY)

# 執行前端腳本，批次產生查詢網址
print("正在執行前端腳本生成查詢...")
script = f"""
    var params_collection = {json.dumps(params_collection)};
    console.log('開始執行查詢，共', params_collection.length, '筆');

    // 逐一觸發查詢
    for (let i = 0; i < params_collection.length; i++) {{
        try {{
            console.log('執行查詢', i + 1, '/', params_collection.length);
            window.common.loadQueryPrice2(params_collection[i]);
        }} catch (e) {{
            console.error('查詢失敗:', e);
        }}
    }}
    console.log('所有查詢已觸發');
"""

driver.execute_script(script)

# 等待所有請求完成
print("等待網路請求完成...")
time.sleep(10)  # 增加等待時間確保所有請求都被記錄

# 從 Network Log 中擷取查詢網址和 payload
print("正在分析網路日誌...")
i = 0
log_entries = driver.get_log("performance")

for entry in log_entries:
    try:
        log = entry['message']
        logJson = json.loads(log)
        message = logJson.get('message', {})
        method = message.get('method', '')

        if method == 'Network.requestWillBeSent':
            request_data = message.get('params', {}).get('request', {})
            url = request_data.get('url', '')

            # 檢查是否為目標 API 請求
            if '/SERVICE/QueryPrice' in url:
                print(f"找到 API 請求 {i + 1}: {url}")

                if i < len(queries):
                    queries[i]['url'] = url

                    # 檢查是否有 POST 資料
                    post_data = request_data.get('postData', '')
                    if post_data:
                        queries[i]['payload'] = post_data
                        print(f"  - 包含 POST 資料: {post_data[:100]}...")

                    # 檢查 URL 參數
                    parsed_url = urllib.parse.urlparse(url)
                    query_params = urllib.parse.parse_qs(parsed_url.query)
                    if 'q' in query_params:
                        print(f"  - 動態參數 q: {query_params['q'][0][:50]}...")

                    i += 1

    except (json.JSONDecodeError, KeyError) as e:
        continue

driver.quit()
print(f"成功獲取 {i} 個查詢網址")

# 透過 requests 模組發送請求並儲存資料
success_count = 0
for idx, query in enumerate(queries):
    if not query['url']:
        print(f"跳過沒有URL的查詢: {query['city']['name']} {query['town']['name']}")
        continue

    CITY_NAME = query['city'].get('name')
    DISTRICT_NAME = query['town'].get('name')

    # 建立目錄
    dir_path = os.path.join(DIRECTORY, CITY_NAME)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

    file_path = os.path.join(dir_path, f'{DISTRICT_NAME}.json')

    # 檢查檔案是否已存在
    if os.path.exists(file_path):
        print(f"檔案已存在，跳過: {CITY_NAME} {DISTRICT_NAME}")
        continue

    print(f"正在查詢 [{idx+1}/{len(queries)}]: {CITY_NAME} {DISTRICT_NAME}")

    try:
        # 設置請求標頭
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Referer': 'https://lvr.land.moi.gov.tw/jsp/list.jsp',
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Accept-Language': 'zh-TW,zh;q=0.9,en;q=0.8',
            'X-Requested-With': 'XMLHttpRequest'
        }

        # 發送請求
        if query['payload']:
            # 如果有 POST 資料，使用 POST 請求
            response = requests.post(
                query['url'],
                data=query['payload'],
                headers=headers,
                timeout=REQUEST_TIMEOUT
            )
        else:
            # 否則使用 GET 請求
            response = requests.get(
                query['url'],
                headers=headers,
                timeout=REQUEST_TIMEOUT
            )

        response.raise_for_status()

        # 儲存資料
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(response.text)

        print(f"  ✓ 成功儲存: {CITY_NAME} {DISTRICT_NAME}")
        success_count += 1

    except Exception as e:
        print(f"  ✗ 錯誤: {CITY_NAME} {DISTRICT_NAME} - {str(e)}")
        continue

    # 延遲避免被封鎖
    time.sleep(SECONDS_DELAY)

print(f"\n爬取完成！成功獲取 {success_count} 個行政區的資料")

import asyncio
from playwright.async_api import async_playwright
import json
import os
import time
from datetime import datetime
import nest_asyncio
import aiohttp

nest_asyncio.apply()  # 避免 Jupyter 環境報 asyncio.run 錯

SECONDS_DELAY = 5
REQUEST_TIMEOUT = 60
DIRECTORY = 'data'
CITIES_URL = "https://gist.githubusercontent.com/abc873693/2804e64324eaaf26515281710e1792df/raw/a1e1fc17d04b47c564bbd9dba0d59a6a325ec7c1/taiwan_districts.json"
URL_INDEX = 'https://lvr.land.moi.gov.tw/jsp/list.jsp'

year = datetime.now().year - 1911
month = datetime.now().month

async def main():
    # 讀取城市與行政區資料
    async with aiohttp.ClientSession() as session:
        async with session.get(CITIES_URL) as resp:
            text = await resp.text()
            cities = json.loads(text)
    print(f"✅ 成功載入 {len(cities)} 個城市資料")

    queries = []
    for city in cities:
        if 'districts' in city:
            for district in city['districts']:
                queries.append({
                    'city': {'id': city.get('id'), 'name': city.get('name')},
                    'town': {'id': district.get('id'), 'name': district.get('name')},
                })
    print(f"✅ 總共建立 {len(queries)} 個查詢")

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()

        results = {}

        # 攔截 JSON 回應
        async def handle_response(response):
            if "/SERVICE/QueryPrice" in response.url:
                try:
                    data = await response.json()
                    results[response.url] = data
                    print(f"📥 成功取得資料: {response.url}")
                except Exception as e:
                    print(f"❌ 解析 JSON 失敗: {response.url} - {str(e)}")

        page.on("response", handle_response)

        await page.goto(URL_INDEX)
        await asyncio.sleep(SECONDS_DELAY)

        # 查詢參數
        params = {
            # 型態
            #  1. 房地
            #  2. 房地（車）
            #  3. 土地
            #  4. 建物
            #  5. 車位
            "ptype": "1,2,3,4,5",

            # 查詢起始年
            "starty": "101",

            # 查詢起始月
            "startm": "1",

            # 查詢結束年
            "endy": str(year),

            # 查詢結束月
            "endm": str(month),

            # 查詢類型
            # biz: 「買賣查詢」
            # rent: 「租賃查詢」
            # sale: 「預售屋查詢」
            "qryType": "biz",

            # 城市
            "city": "A",

            # 行政區
            "town": "A15",

            # 社區名稱
            "p_build": "",

            # 「類型」－公寓、廠房...，僅限「租賃查詢」
            "ftype": "",

            # 租金總額－最低，僅限「租賃查詢」
            "price_s": "",

            # 租金總額－最高
            "price_e": "",

            # 最低單價
            "unit_price_s": "",

            # 最高單價
            "unit_price_e": "",

            # 最低面積
            "area_s": "",

            # 最高面積
            "area_e": "",

            "build_s": "",
            "build_e": "",

            # 最低屋齡
            "buildyear_s": "",

            # 最高屋齡
            "buildyear_e": "",

            "doorno": "",
            "pattern": "",
            "community": "",
            "floor": "",
            "rent_type": "",
            "rent_order": "",
            "urban": "",
            "urbantext": "",
            "nurban": "",
            "aa12": "",
            "p_purpose": "",
            "p_unusual_yn": "",
            "p_unusualcode": "",
            "QB41": "",
            "tmoney_unit": "1",

            # 單價單位
            # 1: 萬元
            # 2: 元
            "pmoney_unit": "1",

            # 面積單位
            # 1: 平方公尺
            # 2: 坪,
            "unit": "2",

            # token
            "token": ""
        }

        params_collection = [dict(params, city=query.get('city').get('id'), town=query.get('town').get('id')) for query in queries]

        # 依序查詢
        for idx, q in enumerate(queries):
            query_params = dict(params)
            query_params["city"] = q['city']['id']
            query_params["town"] = q['town']['id']
            print(f"🔍 查詢 {idx+1}/{len(queries)}: {q['city']['name']} {q['town']['name']}")

            await page.evaluate("window.common.loadQueryPrice2", query_params)
            await asyncio.sleep(1.5)  # 稍微等一下避免伺服器過載

        print("⌛ 等待所有資料回應...")
        await asyncio.sleep(10)

        # 將資料存成檔案
        for url, data in results.items():
            matched = None
            for q in queries:
                if f"city={q['city']['id']}" in url and f"town={q['town']['id']}" in url:
                    matched = q
                    break
            if matched:
                city_name = matched['city']['name']
                town_name = matched['town']['name']
                dir_path = os.path.join(DIRECTORY, city_name)
                os.makedirs(dir_path, exist_ok=True)
                file_path = os.path.join(dir_path, f"{town_name}.json")
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                print(f"💾 已儲存: {city_name} {town_name}")

        await browser.close()
        print("✅ 所有流程完成")
asyncio.run(main())

